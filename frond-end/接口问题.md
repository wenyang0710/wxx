1. 接口返回数据形式为
```
{
    data:[{},{}],
    message:'一些文字',
    state:1,
    total:100
}
// 返回数据结构混乱：由于所有数据在 `data` 里面，而 `total` 在外面，导致无法在拦截器里面统一处理成功或错误之后，返给每个页面数据。所以在拦截器里面需要直接将这个对象返给页面。
// 无法统一错误处理：由于 `state` 也是作为判断是否真的请求到数据，成功还是失败的条件，而返给页面的时候必须带上这个参数，所以每个页面要自己单独判断 `state == 1` ，无法统一错误处理
```

```
// 解决办法
{
    data:{
        data:[{},{}],
        total
    },
    message:'一些文字',
    state:1,
}
```

2. 每条数据都有一个 id ，但如果数据是这样的

```
A = [{id:123123,name:'方法'}]

B = [{id:655786,name:'方法名称',method_id:123123}]

// 如果要相互查的时候要注意，A 的 `id` 就是 B 的 `method_id`
```

```
// 解决办法
A = [{method_id:123123,name:'方法'}]
B = [{B_id:655786,name:'方法名称',method_id:123123}]
```

3. 同样是“启用状态”，可能每个页面用的是不同的名字，如部分页面是 `statue` ，judegMethod页面的是 `check_method_statue` 

```
// 解决办法

// 统一成一个字段名即可


4. 考核管理模块，分公司和个人用的是两套接口，即使入参出参都一致。
// 解决办法
// 换成一套接口，以type区分分公司和个人即可
```


5. 没有超级管理员
现在前端的联调包括，各个模块及接口的联调，和整个流程的联调
“整个流程”，指的是，不同的角色来配置，审核，分发和归档，而无法让一个超级管理员自己配完之后，自己审核，自己分发，自己归档，必须通过不断的切换账号来测试整个流程是否正确。
也就是说，前端必须了解每一条数据从哪个角色创建，哪个角色审核，分发到哪个角色。没有一个超级管理员来一次走完所有流程，给前端接口联调带来极大困难
// 解决办法
// 前端不用走流程，测试各个模块及接口是否正确返回即可。

6. 排序
现在所有的页面的排序方式，都需要前端传，因为原型上没有让用户可自主选择排序方式，所以后台应该给默认的排序方式给前端，而不是让前端自己传排序方式
就算是以后需要加一个“让用户选择排序方式”的需求，也许后台不需要额外的开发时间，但前端不管前期做没做排序的入参，都需要开发时间，因为原型变了。
目前的方式，给前端增加了不必要的工作量

7. 报错的表达形式
现在很多的报错都提示“未将对象引用设置到对象的实例。”“方法 System.Linq.IQueryable`1[TSource] Take[TSource](System.Linq.IQueryable`1[TSource], Int32) 是泛型方法定义”或者一些其他看不懂的东西，前端不可能将这些报错信息展示给用户，而这些报错信息，除了返回的文字不一样，其他的都是一样的，前端没法做区分来告诉用户到底是出什么错了
